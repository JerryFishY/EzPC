def void StartComputation()
{
	return;
}

def void EndComputation()
{
	return;
}

(* ClearemSecret *)

def void ClearMemSecret1(int32_pl s1, float_al[s1] arr)
{
	return;
}

def void ClearMemSecret2(int32_pl s1, int32_pl s2, float_al[s1][s2] arr)
{
	return;
}

def void ClearMemSecret3(int32_pl s1, int32_pl s2, int32_pl s3, float_al[s1][s2][s3] arr)
{
	return;
}

def void ClearMemSecret4(int32_pl s1, int32_pl s2, int32_pl s3, int32_pl s4, float_al[s1][s2][s3][s4] arr)
{
	return;
}

def void MatMul2D(int32_pl i, int32_pl j, int32_pl k, float_al[i][j] A, float_al[j][k] B, float_al[i][k] C, bool_pl modelIsA)
{
	for i1=[0:i]{
		for i2=[0:k]{
			C[i1][i2] = 0.0;
			for i3=[0:j]{
				C[i1][i2] = C[i1][i2] +_al (A[i1][i3]*B[i3][i2]);
			};
		};
	};
}


def void Reassign1(int32_pl s1, float_al[s1] inArr, float_al[s1] outArr) {
	for i1=[0:s1] {
		outArr[i1] = inArr[i1] ;
	} ;
}

def void Reassign2(int32_pl s1, int32_pl s2, float_al[s1][s2] inArr, float_al[s1][s2] outArr) {
	for i1=[0:s1] {
		for i2=[0:s2] {
			outArr[i1][i2] = inArr[i1][i2] ;
		} ;
	} ;
}

def void Reassign3(int32_pl s1, int32_pl s2, int32_pl s3, float_al[s1][s2][s3] inArr, float_al[s1][s2][s3] outArr) {
	for i1=[0:s1] {
		for i2=[0:s2] {
			for i3=[0:s3] {
				outArr[i1][i2][i3] = inArr[i1][i2][i3] ;
			} ;
		} ;
	} ;
}

def void Reassign4(int32_pl s1, int32_pl s2, int32_pl s3, int32_pl s4, float_al[s1][s2][s3][s4] inArr, float_al[s1][s2][s3][s4] outArr) {
	for i1=[0:s1] {
		for i2=[0:s2] {
			for i3=[0:s3] {
				for i4=[0:s4] {
					outArr[i1][i2][i3][i4] = inArr[i1][i2][i3][i4] ;
				} ;
			} ;
		} ;
	} ;
}

(* Relu *)

def void Relu(int32_pl s1, float_al[s1] inArr, float_al[s1] outArr)
{
	for i1=[0:s1]{
		outArr[i1] = ((inArr[i1] > 0.0) ? inArr[i1] : 0.0);
	};
}

def void Relu1(int32_pl s1, float_al[s1] inArr, float_al[s1] outArr)
{
	Relu(s1, inArr, outArr);
}

def void Relu2(int32_pl s1, int32_pl s2, float_al[s1][s2] inArr, float_al[s1][s2] outArr)
{
	int32_pl size = s1*s2;
	float_al[size] reshapedInArr;
	float_al[size] reshapedOutArr;
	for i1=[0:s1]{
		for i2=[0:s2]{
			int32_pl linIdx = (i1*s2) + (i2);
			reshapedInArr[linIdx] = inArr[i1][i2];
		};
	};
	Relu(size, reshapedInArr, reshapedOutArr);
	for i1=[0:s1]{
		for i2=[0:s2]{
			int32_pl linIdx = (i1*s2) + (i2);
			outArr[i1][i2] = reshapedOutArr[linIdx];
		};
	};

	ClearMemSecret1(size, reshapedInArr);
	ClearMemSecret1(size, reshapedOutArr);
}

def void Relu4(int32_pl s1, int32_pl s2, int32_pl s3, int32_pl s4, float_al[s1][s2][s3][s4] inArr, float_al[s1][s2][s3][s4] outArr)
{
	int32_pl size = s1*s2*s3*s4;
	float_al[size] reshapedInArr;
	float_al[size] reshapedOutArr;
	for i1=[0:s1]{
		for i2=[0:s2]{
			for i3=[0:s3]{
				for i4=[0:s4]{
					int32_pl linIdx = (i1*s2*s3*s4) + (i2*s3*s4) + (i3*s4) + i4;
					reshapedInArr[linIdx] = inArr[i1][i2][i3][i4];
				};
			};
		};
	};
	Relu(size, reshapedInArr, reshapedOutArr);
	for i1=[0:s1]{
		for i2=[0:s2]{
			for i3=[0:s3]{
				for i4=[0:s4]{
					int32_pl linIdx = (i1*s2*s3*s4) + (i2*s3*s4) + (i3*s4) + i4;
					outArr[i1][i2][i3][i4] = reshapedOutArr[linIdx];
				};
			};
		};
	};

	ClearMemSecret1(size, reshapedInArr);
	ClearMemSecret1(size, reshapedOutArr);
}

(* Softmax and Sigmoid *)

def void Softmax2(int32_pl s1, int32_pl s2, float_al[s1][s2] inp, float_al[s1][s2] out)
{
	Reassign2(s1, s2, inp, out) ;
}

def void Softmax4(int32_pl s1, int32_pl s2, int32_pl s3, int32_pl s4, float_al[s1][s2][s3][s4] inp, float_al[s1][s2][s3][s4] out)
{
	Reassign4(s1, s2, s3, s4, inp, out) ;
}

def void Sigmoid1(int32_pl s1, float_al[s1] inp, float_al[s1] out)
{
	Reassign1(s1, inp, out) ;
}

def void Sigmoid2(int32_pl s1, int32_pl s2, float_al[s1][s2] inp, float_al[s1][s2] out)
{
	Reassign2(s1, s2, inp, out) ;
}

def void Sigmoid3(int32_pl s1, int32_pl s2, int32_pl s3, float_al[s1][s2][s3] inp, float_al[s1][s2][s3] out)
{
	Reassign3(s1, s2, s3, inp, out) ;
}

def void Sigmoid4(int32_pl s1, int32_pl s2, int32_pl s3, int32_pl s4, float_al[s1][s2][s3][s4] inp, float_al[s1][s2][s3][s4] out)
{
	Reassign4(s1, s2, s3, s4, inp, out) ;
}

(* ClearemSecret *)

def void ElemWiseDiv(int32_pl s1, float_al[s1] arr1, float_al[s1] arr2, float_al[s1] outArr)
{
	for ii=[0:s1]{
		outArr[ii] = (arr1[ii] / arr2[ii]);
	};
}

def void Conv2DReshapeMatMulOPGroup(int32_pl N, int32_pl finalH, int32_pl finalW, int32_pl CO, int32_pl g, int32_pl G, float_al[CO/G][N*finalH*finalW] inputArr, float_al[N][finalH][finalW][CO] outputArr){
	
	int32_pl COG = CO/G;
	int32_pl startCO = g*COG;

	for co=[0:COG]{
		for n=[0:N]{
			for h=[0:finalH]{
				for w=[0:finalW]{
					outputArr[n][h][w][co+startCO] = inputArr[co][(n*finalH*finalW) + (h*finalW) + w];
				};
			};
		};
	};
}


def void Conv2DReshapeFilterGroup(int32_pl FH, int32_pl FW, int32_pl CI, int32_pl CO, int32_pl g, int32_pl G, float_al[FH][FW][CI/G][CO] inputArr, float_al[CO/G][FH*FW*(CI/G)] outputArr){
	
	int32_pl CIG = CI/G;
	int32_pl COG = CO/G;
	int32_pl startCO = g*COG;

	for co=[0:COG]{
		for fh=[0:FH]{
			for fw=[0:FW]{
				for ci=[0:CIG]{
					int32_pl linIdx = (fh*FW*CIG) + (fw*CIG) + ci;
					outputArr[co][linIdx] = inputArr[fh][fw][ci][co+startCO];
				};
			};
		};
	};
}

def void Conv2DReshapeInputGroup(int32_pl N, int32_pl H, int32_pl W, int32_pl CI, int32_pl FH, int32_pl FW, int32_pl zPadHLeft, int32_pl zPadHRight, int32_pl zPadWLeft, int32_pl zPadWRight, int32_pl strideH, int32_pl strideW, int32_pl g, int32_pl G, int32_pl RRows, int32_pl RCols, float_al[N][H][W][CI] inputArr, float_al[RRows][RCols] outputArr){
	int32_pl linIdxFilterMult = 0;
	int32_pl CIG = CI/G;

	for n=[0:N]{
		int32_pl leftTopCornerH = 0 - zPadHLeft;
		int32_pl extremeRightBottomCornerH = H - 1 + zPadHRight;
		while((leftTopCornerH + FH - 1) <= extremeRightBottomCornerH){
			int32_pl leftTopCornerW = 0 - zPadWLeft;
			int32_pl extremeRightBottomCornerW = W - 1 + zPadWRight;
			while((leftTopCornerW + FW - 1) <= extremeRightBottomCornerW){

				for fh=[0:FH]{
					for fw=[0:FW]{
						int32_pl curPosH = leftTopCornerH + fh;
						int32_pl curPosW = leftTopCornerW + fw;
						float_al val = 0.0;

						int32_pl startCI = g*CIG;

						for ci=[0:CIG]{
							if ((((curPosH < 0) || (curPosH >= H)) || ((curPosW < 0) || (curPosW >= W)))){
								val = 0.0;
							}
							else{
								val = inputArr[n][curPosH][curPosW][ci+startCI];
							};
							outputArr[(fh*FW*CIG) + (fw*CIG) + ci][linIdxFilterMult] = val;
						};
					};
				};

				linIdxFilterMult = linIdxFilterMult + 1;
				leftTopCornerW = leftTopCornerW + strideW;
			};

			leftTopCornerH = leftTopCornerH + strideH;
		};
	};
}


def void Conv2DGroup(int32_pl N, int32_pl H, int32_pl W, int32_pl CI, 
				   int32_pl FH, int32_pl FW, int32_pl CO, 
				   int32_pl zPadHLeft, int32_pl zPadHRight, int32_pl zPadWLeft, int32_pl zPadWRight, 
				   int32_pl strideH, int32_pl strideW, int32_pl G,
				   float_al[N][H][W][CI] inputArr, 
				   float_al[FH][FW][CI/G][CO] filterArr, 
				   float_al[N][((H-FH+(zPadHLeft+zPadHRight))/strideH)+1][((W-FW+(zPadWLeft+zPadWRight))/strideW)+1][CO] outArr)
{
	int32_pl CIG = CI/G;	
	int32_pl reshapedFilterRows = CO/G;
	int32_pl reshapedFilterCols = FH*FW*CIG;
	int32_pl reshapedIPRows = FH*FW*CIG;
	int32_pl outH = (((H + (zPadHLeft+zPadHRight) - FH)/strideH) + 1);
	int32_pl outW = (((W + (zPadWLeft+zPadWRight) - FW)/strideW) + 1);
	int32_pl reshapedIPCols = N * outH * outW;


	for g=[0:G]{
		float_al[reshapedIPRows][reshapedIPCols] inputReshaped;
		float_al[reshapedFilterRows][reshapedIPCols] matmulOP;
		float_al[reshapedFilterRows][reshapedFilterCols] filterReshaped;

		Conv2DReshapeFilterGroup(FH, FW, CI, CO, g, G, filterArr, filterReshaped);
		Conv2DReshapeInputGroup(N, H, W, CI, FH, FW, zPadHLeft, zPadHRight, zPadWLeft, zPadWRight, strideH, strideW, g, G, reshapedIPRows, reshapedIPCols, inputArr, inputReshaped);

		MatMul2D(reshapedFilterRows, reshapedFilterCols, reshapedIPCols, filterReshaped, inputReshaped, matmulOP, true);
		
		Conv2DReshapeMatMulOPGroup(N, outH, outW, CO, g, G, matmulOP, outArr);

		ClearMemSecret2(reshapedIPRows, reshapedIPCols, inputReshaped);
		ClearMemSecret2(reshapedFilterRows, reshapedIPCols, matmulOP);
		ClearMemSecret2(reshapedFilterRows, reshapedFilterCols, filterReshaped);
	}
}


def void Conv2DGroupWrapper(int32_pl N, int32_pl H, int32_pl W, int32_pl CI, 
				   int32_pl FH, int32_pl FW, int32_pl CO, 
				   int32_pl zPadHLeft, int32_pl zPadHRight, int32_pl zPadWLeft, int32_pl zPadWRight, 
				   int32_pl strideH, int32_pl strideW, int32_pl G,
				   float_al[N][H][W][CI] inputArr, 
				   float_al[FH][FW][CI/G][CO] filterArr, 
				   float_al[N][((H-FH+(zPadHLeft+zPadHRight))/strideH)+1][((W-FW+(zPadWLeft+zPadWRight))/strideW)+1][CO] outArr)

{	Conv2DGroup(N, H, W, CI, FH, FW, CO, zPadHLeft, zPadHRight, zPadWLeft, zPadWRight, strideH, strideW, G, inputArr, filterArr, outArr);
}
