extern void WinogradM4R3ImageTransform(int64_al[6][6] D, int64_al[6][6] M) ;

extern void WinogradM4R3OutputTransform(int64_al[6][6] M, int64_al[4][4] C) ;

extern void WinogradM4R5ImageTransform(int64_al[8][8] D, int64_al[8][8] M) ;

extern void WinogradM4R5OutputTransform(int64_al[8][8] M, int64_al[4][4] C) ;

extern void WinogradM2R5ImageTransform(int64_al[6][6] D, int64_al[6][6] M) ;

extern void WinogradM2R5OutputTransform(int64_al[6][6] M, int64_al[2][2] C) ;

def void Conv2DWinoSingleCOT(int32_pl m, int32_pl r, int32_pl N, int32_pl H, int32_pl W, int32_pl CI, int32_pl CO, 
				   int32_pl zPadHLeft, int32_pl zPadHRight, int32_pl zPadWLeft, int32_pl zPadWRight,
				   int64_al[N][H][W][CI] inputArr, 
				   int64_al[m+r-1][m+r-1][CI][CO] transformedFilter, 
				   int64_al[N][H+zPadHLeft+zPadHRight-r+1][W+zPadWLeft+zPadWRight-r+1][CO] outArr) {

	int32_pl n = m + r - 1 ;

	int32_pl truH = H + zPadHLeft + zPadHRight ;
	int32_pl truW = W + zPadWLeft + zPadWRight ;
	int32_pl outH = truH - r + 1 ;
	int32_pl outW = truW - r + 1 ;

	int64_al[N][CI][truH][truW] truInputImg ;

	for i1=[0:N] {
		for i2=[0:CI] {

			for i3=[0:truH] {
				for i4=[0:truW] {

					if ((zPadHLeft <= i3) && (i3 < (zPadHLeft + H)) && (zPadWLeft <= i4) && (i4 < (zPadWLeft + W))) {
						truInputImg[i1][i2][i3][i4] = inputArr[i1][i3-zPadHLeft][i4-zPadWLeft][i2] ;
					} else {
						truInputImg[i1][i2][i3][i4] = 0L ;
					} ;

				} ;
			} ;

		} ;
	} ;

	int32_pl TH ;
	int32_pl TW ;

	if (((truH - r + 1) % m) == 0) {
		TH = (truH - r + 1) / m ;
	} else {
		TH = ((truH - r + 1) / m) + 1 ;
	} ;

	if (((truW - r + 1) % m) == 0) {
		TW = (truW - r + 1) / m ;
	} else {
		TW = ((truW - r + 1) / m) + 1 ;
	} ;

	int64_al[N][CI][TH][TW][n][n] inputTiles ;

	for i1=[0:N] {
		for i2=[0:CI] {

			for th=[0:TH] {
				for tw=[0:TW] {

					int64_al[n][n] inputBlock ;
					int64_al[n][n] inputTransformed ;

					for i=[0:n] {
						for j=[0:n] {
							int32_pl indH ;
							int32_pl indW ;

							indH = (th*m) + i ;
							indW = (tw*m) + j ;

							if ((indH < truH) && (indW < truW)) {
								inputBlock[i][j] = truInputImg[i1][i2][indH][indW] ;
							} else {
								inputBlock[i][j] = 0L ;
							} ;

						} ;
					} ;

					if (r == 3) {
						WinogradM4R3ImageTransform(inputBlock, inputTransformed) ;
					} else {
					if (r == 5) {
						WinogradM2R5ImageTransform(inputBlock, inputTransformed) ;
					} ;
					} ;

					for i=[0:n] {
						for j=[0:n] {
							inputTiles[i1][i2][th][tw][i][j] = inputTransformed[i][j] ;
						} ;
					} ;

					ClearMemSecret2(n, n, inputBlock) ;
					ClearMemSecret2(n, n, inputTransformed) ;

				} ;
			} ;
		} ;
	} ;

	ClearMemSecret4(N, CI, truH, truW, truInputImg) ;

	int32_pl s1 = TH*TW ;
	int32_pl s2 = CO*CI*n*n ;

	int64_al[s1][s2] mul1 ;
	int64_al[s2][1] mul2 ;
	int64_al[s1][s2] mulout ;

	for co=[0:CO] {

		for th=[0:TH] {
			for tw=[0:TW] {

				for ci=[0:CI] {
					for i=[0:n] {
						for j=[0:n] {

							mul1[th*TW + tw][co*CI*n*n + ci*n*n + i*n + j] = inputTiles[0][ci][th][tw][i][j] ;
							mul2[co*CI*n*n + ci*n*n + i*n + j][0] = transformedFilter[i][j][ci][co] ;

						} ;
					} ;
				} ;

			} ;
		} ;
	} ;

	ClearMemSecret6(N, CI, TH, TW, n, n, inputTiles) ;

	WinogradHadamard(s1, s2, 1, mul1, mul2, mulout, false) ;
	ClearMemSecret2(s1, s2, mul1) ;
	ClearMemSecret2(s2, 1, mul2) ;

	int64_al[CO][CI][TH][TW][m][m] outputTiles ;
	int64_al[CO][TH][TW][m][m] reducedTiles ;

	for i2=[0:CO] {
		for i3=[0:CI] {
			for th=[0:TH] {
				for tw=[0:TW] {

					int64_al[n][n] outputBlock ;
					int64_al[m][m] outputTransformed ;

					for i=[0:n] {
						for j=[0:n] {
							outputBlock[i][j] = mulout[th*TW + tw][i2*CI*n*n + i3*n*n + i*n + j]
						} ;
					} ;

					if (r == 3) {
						WinogradM4R3OutputTransform(outputBlock, outputTransformed) ;
					} else {
					if (r == 5) {
						WinogradM2R5OutputTransform(outputBlock, outputTransformed) ;
					} ;
					} ;

					for i=[0:m] {
						for j=[0:m] {
							outputTiles[i2][i3][th][tw][i][j] = outputTransformed[i][j] ;
						} ;
					} ;

					ClearMemSecret2(n, n, outputBlock) ;
					ClearMemSecret2(m, m, outputTransformed) ;

				} ;
			} ;
		} ;
	} ;

	ClearMemSecret2(s1, s2, mulout) ;

	for i2=[0:CO] {
		for th=[0:TH] {
			for tw=[0:TW] {
				for i=[0:m] {
					for j=[0:m] {

						reducedTiles[i2][th][tw][i][j] = outputTiles[i2][0][th][tw][i][j] ;

						for i3=[1:CI] {
							reducedTiles[i2][th][tw][i][j] = reducedTiles[i2][th][tw][i][j] + outputTiles[i2][i3][th][tw][i][j] ; 
						} ;

					} ;
				} ;
			} ;
		} ;
	} ;

	ClearMemSecret6(CO, CI, TH, TW, m, m, outputTiles) ;

	for i2=[0:CO] {
		for th=[0:TH] {
			for tw=[0:TW] {
				int32_pl i3 = th*m ;
				int32_pl i4 = tw*m ;

				for i=[0:m] {
					for j=[0:m] {
						int32_pl indH ;
						int32_pl indW ;

						indH = (th*m) + i ;
						indW = (tw*m) + j ;

						if ((indH < outH) && (indW < outW)) {
							outArr[0][indH][indW][i2] = reducedTiles[i2][th][tw][i][j] ;
						} ;

					} ;
				} ;
			} ;
		} ;
	} ;

	ClearMemSecret5(CO, TH, TW, m, m, reducedTiles) ;
}

def void Conv2DWinoMultipleCOT(int32_pl m, int32_pl r, int32_pl N, int32_pl H, int32_pl W, int32_pl CI, int32_pl CO, 
				   int32_pl zPadHLeft, int32_pl zPadHRight, int32_pl zPadWLeft, int32_pl zPadWRight,
				   int64_al[N][H][W][CI] inputArr, 
				   int64_al[m+r-1][m+r-1][CI][CO] transformedFilter, 
				   int64_al[N][H+zPadHLeft+zPadHRight-r+1][W+zPadWLeft+zPadWRight-r+1][CO] outArr) {

	int32_pl n = m + r - 1 ;

	int32_pl truH = H + zPadHLeft + zPadHRight ;
	int32_pl truW = W + zPadWLeft + zPadWRight ;
	int32_pl outH = truH - r + 1 ;
	int32_pl outW = truW - r + 1 ;

	int64_al[N][CI][truH][truW] truInputImg ;

	for i1=[0:N] {
		for i2=[0:CI] {

			for i3=[0:truH] {
				for i4=[0:truW] {

					if ((zPadHLeft <= i3) && (i3 < (zPadHLeft + H)) && (zPadWLeft <= i4) && (i4 < (zPadWLeft + W))) {
						truInputImg[i1][i2][i3][i4] = inputArr[i1][i3-zPadHLeft][i4-zPadWLeft][i2] ;
					} else {
						truInputImg[i1][i2][i3][i4] = 0L ;
					} ;

				} ;
			} ;

		} ;
	} ;

	int32_pl TH ;
	int32_pl TW ;

	if (((truH - r + 1) % m) == 0) {
		TH = (truH - r + 1) / m ;
	} else {
		TH = ((truH - r + 1) / m) + 1 ;
	} ;

	if (((truW - r + 1) % m) == 0) {
		TW = (truW - r + 1) / m ;
	} else {
		TW = ((truW - r + 1) / m) + 1 ;
	} ;

	int64_al[N][CI][TH][TW][n][n] inputTiles ;

	for i1=[0:N] {
		for i2=[0:CI] {

			for th=[0:TH] {
				for tw=[0:TW] {

					int64_al[n][n] inputBlock ;
					int64_al[n][n] inputTransformed ;

					for i=[0:n] {
						for j=[0:n] {
							int32_pl indH ;
							int32_pl indW ;

							indH = (th*m) + i ;
							indW = (tw*m) + j ;

							if ((indH < truH) && (indW < truW)) {
								inputBlock[i][j] = truInputImg[i1][i2][indH][indW] ;
							} else {
								inputBlock[i][j] = 0L ;
							} ;

						} ;
					} ;

					if (r == 3) {
						WinogradM4R3ImageTransform(inputBlock, inputTransformed) ;
					} else {
					if (r == 5) {
						WinogradM2R5ImageTransform(inputBlock, inputTransformed) ;
					} ;
					} ;

					for i=[0:n] {
						for j=[0:n] {
							inputTiles[i1][i2][th][tw][i][j] = inputTransformed[i][j] ;
						} ;
					} ;

					ClearMemSecret2(n, n, inputBlock) ;
					ClearMemSecret2(n, n, inputTransformed) ;

				} ;
			} ;
		} ;
	} ;

	ClearMemSecret4(N, CI, truH, truW, truInputImg) ;

	int32_pl s1 = CO ;
	int32_pl s2 = TH*TW ;
	int32_pl s3 = CI*n*n ;

	int64_al[s1][s2][s3] mul1 ;
	int64_al[s1][s2][s3] mul2 ;
	int64_al[s1][s2][s3] mulout ;

	for co=[0:CO] {

		for th=[0:TH] {
			for tw=[0:TW] {

				for ci=[0:CI] {
					for i=[0:n] {
						for j=[0:n] {

							mul1[co][th*TW + tw][ci*n*n+i*n+j] = inputTiles[0][ci][th][tw][i][j] ;
							mul2[co][th*TW + tw][ci*n*n+i*n+j] = transformedFilter[i][j][ci][co] ;

						} ;
					} ;
				} ;

			} ;
		} ;
	} ;

	ClearMemSecret6(N, CI, TH, TW, n, n, inputTiles) ;

	for i=[0:s1] {
		int64_al[s2][s3] mat ;
		int64_al[s3][1] vec ;
		int64_al[s2][s3] res ;

		for k=[0:s3] {
			vec[k][0] = mul2[i][0][k] ;
		} ;

		for j=[0:s2] {
			for k=[0:s3] {
				mat[j][k] = mul1[i][j][k] ;
			} ;
		} ;

		WinogradHadamard(s2, s3, 1, mat, vec, res, false) ;

		for j=[0:s2] {
			for k=[0:s3] {
				mulout[i][j][k] = res[j][k] ;
			} ;
		} ;
	} ;

	ClearMemSecret3(s1, s2, s3, mul1) ;
	ClearMemSecret3(s1, s2, s3, mul2) ;

	int64_al[CO][CI][TH][TW][m][m] outputTiles ;
	int64_al[CO][TH][TW][m][m] reducedTiles ;

	for i2=[0:CO] {
		for i3=[0:CI] {
			for th=[0:TH] {
				for tw=[0:TW] {

					int64_al[n][n] outputBlock ;
					int64_al[m][m] outputTransformed ;

					for i=[0:n] {
						for j=[0:n] {
							outputBlock[i][j] = mulout[i2][th*TW + tw][i3*n*n+i*n+j]
						} ;
					} ;

					if (r == 3) {
						WinogradM4R3OutputTransform(outputBlock, outputTransformed) ;
					} else {
					if (r == 5) {
						WinogradM2R5OutputTransform(outputBlock, outputTransformed) ;
					} ;
					} ;

					for i=[0:m] {
						for j=[0:m] {
							outputTiles[i2][i3][th][tw][i][j] = outputTransformed[i][j] ;
						} ;
					} ;

					ClearMemSecret2(n, n, outputBlock) ;
					ClearMemSecret2(m, m, outputTransformed) ;

				} ;
			} ;
		} ;
	} ;

	ClearMemSecret3(s1, s2, s3, mulout) ;

	for i2=[0:CO] {
		for th=[0:TH] {
			for tw=[0:TW] {
				for i=[0:m] {
					for j=[0:m] {

						reducedTiles[i2][th][tw][i][j] = outputTiles[i2][0][th][tw][i][j] ;

						for i3=[1:CI] {
							reducedTiles[i2][th][tw][i][j] = reducedTiles[i2][th][tw][i][j] + outputTiles[i2][i3][th][tw][i][j] ; 
						} ;

					} ;
				} ;
			} ;
		} ;
	} ;

	ClearMemSecret6(CO, CI, TH, TW, m, m, outputTiles) ;

	(* 

	if (r == 5) {
		int32_pl tot = CO*TH*TW ;

		int64_al[CO][TH][TW][2] div2 ;
		int64_al[CO][TH][TW][3] div4 ;
		int64_al[CO][TH][TW][4] div8 ;
		int64_al[CO][TH][TW][3] div16 ;
		int64_al[CO][TH][TW][2] div32 ;
		int64_al[CO][TH][TW][1] div64 ;

		int64_al[CO][TH][TW][2] divd2 ;
		int64_al[CO][TH][TW][3] divd4 ;
		int64_al[CO][TH][TW][4] divd8 ;
		int64_al[CO][TH][TW][3] divd16 ;
		int64_al[CO][TH][TW][2] divd32 ;
		int64_al[CO][TH][TW][1] divd64 ;

		for co=[0:CO] {
			for th=[0:TH] {
				for tw=[0:TW] {
					div2[co][th][tw][0] = reducedTiles[co][th][tw][0][1] ;
					div2[co][th][tw][1] = reducedTiles[co][th][tw][1][0] ;

					div4[co][th][tw][0] = reducedTiles[co][th][tw][0][2] ;
					div4[co][th][tw][1] = reducedTiles[co][th][tw][1][1] ;
					div4[co][th][tw][2] = reducedTiles[co][th][tw][2][0] ;

					div8[co][th][tw][0] = reducedTiles[co][th][tw][0][3] ;
					div8[co][th][tw][1] = reducedTiles[co][th][tw][1][2] ;
					div8[co][th][tw][2] = reducedTiles[co][th][tw][2][1] ;
					div8[co][th][tw][3] = reducedTiles[co][th][tw][3][0] ;

					div16[co][th][tw][0] = reducedTiles[co][th][tw][1][3] ;
					div16[co][th][tw][1] = reducedTiles[co][th][tw][2][2] ;
					div16[co][th][tw][2] = reducedTiles[co][th][tw][3][1] ;

					div32[co][th][tw][0] = reducedTiles[co][th][tw][2][3] ;
					div32[co][th][tw][1] = reducedTiles[co][th][tw][3][2] ;

					div64[co][th][tw][0] = reducedTiles[co][th][tw][3][3] ;
				} ;
			} ;
		} ;

		ElemWisePublicDiv4(CO, TH, TW, 2, div2, 2, divd2) ;
		ElemWisePublicDiv4(CO, TH, TW, 3, div4, 4, divd4) ;
		ElemWisePublicDiv4(CO, TH, TW, 4, div8, 8, divd8) ;
		ElemWisePublicDiv4(CO, TH, TW, 3, div16, 16, divd16) ;
		ElemWisePublicDiv4(CO, TH, TW, 2, div32, 32, divd32) ;
		ElemWisePublicDiv4(CO, TH, TW, 1, div64, 64, divd64) ;

		ClearMemSecret4(CO, TH, TW, 2, div2) ;
		ClearMemSecret4(CO, TH, TW, 3, div4) ;
		ClearMemSecret4(CO, TH, TW, 4, div8) ;
		ClearMemSecret4(CO, TH, TW, 3, div16) ;
		ClearMemSecret4(CO, TH, TW, 2, div32) ;
		ClearMemSecret4(CO, TH, TW, 1, div64) ;

		for co=[0:CO] {
			for th=[0:TH] {
				for tw=[0:TW] {
					 reducedTiles[co][th][tw][0][1] = divd2[co][th][tw][0] ;
					 reducedTiles[co][th][tw][1][0] = divd2[co][th][tw][1] ;

					 reducedTiles[co][th][tw][0][2] = divd4[co][th][tw][0] ;
					 reducedTiles[co][th][tw][1][1] = divd4[co][th][tw][1] ;
					 reducedTiles[co][th][tw][2][0] = divd4[co][th][tw][2] ;

					 reducedTiles[co][th][tw][0][3] = divd8[co][th][tw][0] ;
					 reducedTiles[co][th][tw][1][2] = divd8[co][th][tw][1] ;
					 reducedTiles[co][th][tw][2][1] = divd8[co][th][tw][2] ;
					 reducedTiles[co][th][tw][3][0] = divd8[co][th][tw][3] ;

					 reducedTiles[co][th][tw][1][3] = divd16[co][th][tw][0] ;
					 reducedTiles[co][th][tw][2][2] = divd16[co][th][tw][1] ;
					 reducedTiles[co][th][tw][3][1] = divd16[co][th][tw][2] ;

					 reducedTiles[co][th][tw][2][3] = divd32[co][th][tw][0] ;
					 reducedTiles[co][th][tw][3][2] = divd32[co][th][tw][1] ;
					
					 reducedTiles[co][th][tw][3][3] = divd64[co][th][tw][0] ;
				} ;
			} ;
		} ;

		ClearMemSecret4(CO, TH, TW, 2, divd2) ;
		ClearMemSecret4(CO, TH, TW, 3, divd4) ;
		ClearMemSecret4(CO, TH, TW, 4, divd8) ;
		ClearMemSecret4(CO, TH, TW, 3, divd16) ;
		ClearMemSecret4(CO, TH, TW, 2, divd32) ;
		ClearMemSecret4(CO, TH, TW, 1, divd64) ;
	} ;

	*)

	for i2=[0:CO] {
		for th=[0:TH] {
			for tw=[0:TW] {
				int32_pl i3 = th*m ;
				int32_pl i4 = tw*m ;

				for i=[0:m] {
					for j=[0:m] {
						int32_pl indH ;
						int32_pl indW ;

						indH = (th*m) + i ;
						indW = (tw*m) + j ;

						if ((indH < outH) && (indW < outW)) {
							outArr[0][indH][indW][i2] = reducedTiles[i2][th][tw][i][j] ;
						} ;

					} ;
				} ;
			} ;
		} ;
	} ;

	ClearMemSecret5(CO, TH, TW, m, m, reducedTiles) ;
}

def void Conv2DWinoWrong(int32_pl m, int32_pl r, int32_pl N, int32_pl H, int32_pl W, int32_pl CI, int32_pl CO, 
				   int32_pl zPadHLeft, int32_pl zPadHRight, int32_pl zPadWLeft, int32_pl zPadWRight,
				   int64_al[N][H][W][CI] inputArr, 
				   int64_al[m+r-1][m+r-1][CI][CO] transformedFilter, 
				   int64_al[N][H+zPadHLeft+zPadHRight-r+1][W+zPadWLeft+zPadWRight-r+1][CO] outArr) {

	int32_pl n = m + r - 1 ;

	int32_pl truH = H + zPadHLeft + zPadHRight ;
	int32_pl truW = W + zPadWLeft + zPadWRight ;
	int32_pl outH = truH - r + 1 ;
	int32_pl outW = truW - r + 1 ;

	int64_al[N][CI][truH][truW] truInputImg ;

	for i1=[0:N] {
		for i2=[0:CI] {

			for i3=[0:truH] {
				for i4=[0:truW] {

					if ((zPadHLeft <= i3) && (i3 < (zPadHLeft + H)) && (zPadWLeft <= i4) && (i4 < (zPadWLeft + W))) {
						truInputImg[i1][i2][i3][i4] = inputArr[i1][i3-zPadHLeft][i4-zPadWLeft][i2] ;
					} else {
						truInputImg[i1][i2][i3][i4] = 0L ;
					} ;

				} ;
			} ;

		} ;
	} ;

	int32_pl TH ;
	int32_pl TW ;

	if (((truH - r + 1) % m) == 0) {
		TH = (truH - r + 1) / m ;
	} else {
		TH = ((truH - r + 1) / m) + 1 ;
	} ;

	if (((truW - r + 1) % m) == 0) {
		TW = (truW - r + 1) / m ;
	} else {
		TW = ((truW - r + 1) / m) + 1 ;
	} ;

	int64_al[N][CI][TH][TW][n][n] inputTiles ;

	for i1=[0:N] {
		for i2=[0:CI] {

			for th=[0:TH] {
				for tw=[0:TW] {

					int64_al[n][n] inputBlock ;
					int64_al[n][n] inputTransformed ;

					for i=[0:n] {
						for j=[0:n] {
							int32_pl indH ;
							int32_pl indW ;

							indH = (th*m) + i ;
							indW = (tw*m) + j ;

							if ((indH < truH) && (indW < truW)) {
								inputBlock[i][j] = truInputImg[i1][i2][indH][indW] ;
							} else {
								inputBlock[i][j] = 0L ;
							} ;

						} ;
					} ;

					if (r == 3) {
						WinogradM4R3ImageTransform(inputBlock, inputTransformed) ;
					} else {
					if (r == 5) {
						WinogradM2R5ImageTransform(inputBlock, inputTransformed) ;
					} ;
					} ;

					for i=[0:n] {
						for j=[0:n] {
							inputTiles[i1][i2][th][tw][i][j] = inputTransformed[i][j] ;
						} ;
					} ;

					ClearMemSecret2(n, n, inputBlock) ;
					ClearMemSecret2(n, n, inputTransformed) ;

				} ;
			} ;
		} ;
	} ;

	ClearMemSecret4(N, CI, truH, truW, truInputImg) ;

	int32_pl s1 = CO*TH*TW ;
	int32_pl s2 = CI ;
	int32_pl s3 = n*n ;

	int64_al[s1][s2] mul1 ;
	int64_al[s2][s3] mul2 ;
	int64_al[s1][s3] reducedMul ;

	for co=[0:CO] {
		for th=[0:TH] {
			for tw=[0:TW] {

				for ci=[0:CI] {

					for i=[0:n] {
						for j=[0:n] {

							mul1[co*TH*TW + th*TW + tw][ci] = inputTiles[0][ci][th][tw][i][j] ;
							mul2[ci][i*n+j] = transformedFilter[i][j][ci][co] ;

						} ;
					} ;

				} ;

			} ;
		} ;
	} ;

	MatMul2D(s1, s2, s3, mul1, mul2, reducedMul, false) ;

	ClearMemSecret6(N, CI, TH, TW, n, n, inputTiles) ;
	ClearMemSecret2(s1, s2, mul1) ;
	ClearMemSecret2(s2, s3, mul2) ;

	for i2=[0:CO] {
		for th=[0:TH] {
			for tw=[0:TW] {

				int64_al[n][n] outputBlock ;
				int64_al[m][m] outputTransformed ;

				for i=[0:n] {
					for j=[0:n] {
						outputBlock[i][j] = reducedMul[i2*TH*TW + th*TW + tw][i*n+j]
					} ;
				} ;

				if (r == 3) {
					WinogradM4R3OutputTransform(outputBlock, outputTransformed) ;
				} else {
				if (r == 5) {
					WinogradM2R5OutputTransform(outputBlock, outputTransformed) ;
				} ;
				} ;

				for i=[0:m] {
					for j=[0:m] {
						int32_pl indH ;
						int32_pl indW ;

						indH = (th*m) + i ;
						indW = (tw*m) + j ;

						if ((indH < outH) && (indW < outW)) {
							outArr[0][indH][indW][i2] = outputTransformed[i][j] ;
						} ;
					} ;
				} ;

				ClearMemSecret2(n, n, outputBlock) ;
				ClearMemSecret2(m, m, outputTransformed) ;
			} ;
		} ;
	} ;

	ClearMemSecret2(s2, s3, reducedMul) ;
}

def void Conv2DWinoDW(int32_pl m, int32_pl r, int32_pl N, int32_pl H, int32_pl W, int32_pl C, 
				   int32_pl zPadHLeft, int32_pl zPadHRight, int32_pl zPadWLeft, int32_pl zPadWRight,
				   int64_al[N][H][W][C] inputArr, 
				   int64_al[m+r-1][m+r-1][1][C] transformedFilter, 
				   int64_al[N][H+zPadHLeft+zPadHRight-r+1][W+zPadWLeft+zPadWRight-r+1][C] outArr) {

	int32_pl n = m + r - 1 ;

	int32_pl truH = H + zPadHLeft + zPadHRight ;
	int32_pl truW = W + zPadWLeft + zPadWRight ;
	int32_pl outH = truH - r + 1 ;
	int32_pl outW = truW - r + 1 ;

	int64_al[N][C][truH][truW] truInputImg ;

	for i1=[0:N] {
		for i2=[0:C] {

			for i3=[0:truH] {
				for i4=[0:truW] {

					if ((zPadHLeft <= i3) && (i3 < (zPadHLeft + H)) && (zPadWLeft <= i4) && (i4 < (zPadWLeft + W))) {
						truInputImg[i1][i2][i3][i4] = inputArr[i1][i3-zPadHLeft][i4-zPadWLeft][i2] ;
					} else {
						truInputImg[i1][i2][i3][i4] = 0L ;
					} ;

				} ;
			} ;

		} ;
	} ;

	int32_pl TH ;
	int32_pl TW ;

	if (((truH - r + 1) % m) == 0) {
		TH = (truH - r + 1) / m ;
	} else {
		TH = ((truH - r + 1) / m) + 1 ;
	} ;

	if (((truW - r + 1) % m) == 0) {
		TW = (truW - r + 1) / m ;
	} else {
		TW = ((truW - r + 1) / m) + 1 ;
	} ;

	int64_al[N][C][TH][TW][n][n] inputTiles ;

	for i1=[0:N] {
		for i2=[0:C] {

			for th=[0:TH] {
				for tw=[0:TW] {

					int64_al[n][n] inputBlock ;
					int64_al[n][n] inputTransformed ;

					for i=[0:n] {
						for j=[0:n] {
							int32_pl indH ;
							int32_pl indW ;

							indH = (th*m) + i ;
							indW = (tw*m) + j ;

							if ((indH < truH) && (indW < truW)) {
								inputBlock[i][j] = truInputImg[i1][i2][indH][indW] ;
							} else {
								inputBlock[i][j] = 0L ;
							} ;

						} ;
					} ;

					if (r == 3) {
						WinogradM4R3ImageTransform(inputBlock, inputTransformed) ;
					} else {
					if (r == 5) {
						WinogradM2R5ImageTransform(inputBlock, inputTransformed) ;
					} ;
					} ;


					for i=[0:n] {
						for j=[0:n] {
							inputTiles[i1][i2][th][tw][i][j] = inputTransformed[i][j] ;
						} ;
					} ;

					ClearMemSecret2(n, n, inputBlock) ;
					ClearMemSecret2(n, n, inputTransformed) ;

				} ;
			} ;
		} ;
	} ;

	ClearMemSecret4(N, C, truH, truW, truInputImg) ;

	int32_pl s2 = TH*TW ;
	int32_pl s3 = C*n*n ;

	int64_al[s2][s3] mul1 ;
	int64_al[s2][s3] mul2 ;
	int64_al[s2][s3] mulout ;

	for th=[0:TH] {
		for tw=[0:TW] {

			for c=[0:C] {
				for i=[0:n] {
					for j=[0:n] {

						mul1[th*TW + tw][c*n*n+i*n+j] = inputTiles[0][c][th][tw][i][j] ;
						mul2[th*TW + tw][c*n*n+i*n+j] = transformedFilter[i][j][0][c] ;

					} ;
				} ;
			} ;

		} ;
	} ;

	ClearMemSecret6(N, C, TH, TW, n, n, inputTiles) ;

	int64_al[s2][s3] mat ;
	int64_al[s3][1] vec ;
	int64_al[s2][s3] res ;

	for k=[0:s3] {
		vec[k][0] = mul2[0][k] ;
	} ;

	for j=[0:s2] {
		for k=[0:s3] {
			mat[j][k] = mul1[j][k] ;
		} ;
	} ;

	ClearMemSecret2(s2, s3, mul1) ;
	ClearMemSecret2(s2, s3, mul2) ;

	WinogradHadamard(s2, s3, 1, mat, vec, res, false) ;

	for j=[0:s2] {
		for k=[0:s3] {
			mulout[j][k] = res[j][k] ;
		} ;
	} ;

	ClearMemSecret2(s2, s3, mat) ;
	ClearMemSecret2(s3, 1, vec) ;
	ClearMemSecret2(s2, s3, res) ;

	int64_al[C][TH][TW][m][m] outputTiles ;

	for i3=[0:C] {
		for th=[0:TH] {
			for tw=[0:TW] {

				int64_al[n][n] outputBlock ;
				int64_al[m][m] outputTransformed ;

				for i=[0:n] {
					for j=[0:n] {
						outputBlock[i][j] = mulout[th*TW + tw][i3*n*n+i*n+j]
					} ;
				} ;

					if (r == 3) {
						WinogradM4R3OutputTransform(outputBlock, outputTransformed) ;
					} else {
					if (r == 5) {
						WinogradM2R5OutputTransform(outputBlock, outputTransformed) ;
					} ;
					} ;

				for i=[0:m] {
					for j=[0:m] {
						outputTiles[i3][th][tw][i][j] = outputTransformed[i][j] ;
					} ;
				} ;

				ClearMemSecret2(n, n, outputBlock) ;
				ClearMemSecret2(m, m, outputTransformed) ;

			} ;
		} ;
	} ;

	ClearMemSecret2(s2, s3, mulout) ;

	(*

	if (r == 5) {
		int64_al[C][TH][TW][2] div2 ;
		int64_al[C][TH][TW][3] div4 ;
		int64_al[C][TH][TW][4] div8 ;
		int64_al[C][TH][TW][3] div16 ;
		int64_al[C][TH][TW][2] div32 ;
		int64_al[C][TH][TW][1] div64 ;

		int64_al[C][TH][TW][2] divd2 ;
		int64_al[C][TH][TW][3] divd4 ;
		int64_al[C][TH][TW][4] divd8 ;
		int64_al[C][TH][TW][3] divd16 ;
		int64_al[C][TH][TW][2] divd32 ;
		int64_al[C][TH][TW][1] divd64 ;

		for co=[0:C] {
			for th=[0:TH] {
				for tw=[0:TW] {
					div2[co][th][tw][0] = outputTiles[co][th][tw][0][1] ;
					div2[co][th][tw][1] = outputTiles[co][th][tw][1][0] ;

					div4[co][th][tw][0] = outputTiles[co][th][tw][0][2] ;
					div4[co][th][tw][1] = outputTiles[co][th][tw][1][1] ;
					div4[co][th][tw][2] = outputTiles[co][th][tw][2][0] ;

					div8[co][th][tw][0] = outputTiles[co][th][tw][0][3] ;
					div8[co][th][tw][1] = outputTiles[co][th][tw][1][2] ;
					div8[co][th][tw][2] = outputTiles[co][th][tw][2][1] ;
					div8[co][th][tw][3] = outputTiles[co][th][tw][3][0] ;

					div16[co][th][tw][0] = outputTiles[co][th][tw][1][3] ;
					div16[co][th][tw][1] = outputTiles[co][th][tw][2][2] ;
					div16[co][th][tw][2] = outputTiles[co][th][tw][3][1] ;

					div32[co][th][tw][0] = outputTiles[co][th][tw][2][3] ;
					div32[co][th][tw][1] = outputTiles[co][th][tw][3][2] ;

					div64[co][th][tw][0] = outputTiles[co][th][tw][3][3] ;
				} ;
			} ;
		} ;

		ElemWisePublicDiv4(C, TH, TW, 2, div2, 2, divd2) ;
		ElemWisePublicDiv4(C, TH, TW, 3, div4, 4, divd4) ;
		ElemWisePublicDiv4(C, TH, TW, 4, div8, 8, divd8) ;
		ElemWisePublicDiv4(C, TH, TW, 3, div16, 16, divd16) ;
		ElemWisePublicDiv4(C, TH, TW, 2, div32, 32, divd32) ;
		ElemWisePublicDiv4(C, TH, TW, 1, div64, 64, divd64) ;

		ClearMemSecret4(C, TH, TW, 2, div2) ;
		ClearMemSecret4(C, TH, TW, 3, div4) ;
		ClearMemSecret4(C, TH, TW, 4, div8) ;
		ClearMemSecret4(C, TH, TW, 3, div16) ;
		ClearMemSecret4(C, TH, TW, 2, div32) ;
		ClearMemSecret4(C, TH, TW, 1, div64) ;

		for co=[0:C] {
			for th=[0:TH] {
				for tw=[0:TW] {
					 outputTiles[co][th][tw][0][1] = divd2[co][th][tw][0] ;
					 outputTiles[co][th][tw][1][0] = divd2[co][th][tw][1] ;

					 outputTiles[co][th][tw][0][2] = divd4[co][th][tw][0] ;
					 outputTiles[co][th][tw][1][1] = divd4[co][th][tw][1] ;
					 outputTiles[co][th][tw][2][0] = divd4[co][th][tw][2] ;

					 outputTiles[co][th][tw][0][3] = divd8[co][th][tw][0] ;
					 outputTiles[co][th][tw][1][2] = divd8[co][th][tw][1] ;
					 outputTiles[co][th][tw][2][1] = divd8[co][th][tw][2] ;
					 outputTiles[co][th][tw][3][0] = divd8[co][th][tw][3] ;

					 outputTiles[co][th][tw][1][3] = divd16[co][th][tw][0] ;
					 outputTiles[co][th][tw][2][2] = divd16[co][th][tw][1] ;
					 outputTiles[co][th][tw][3][1] = divd16[co][th][tw][2] ;

					 outputTiles[co][th][tw][2][3] = divd32[co][th][tw][0] ;
					 outputTiles[co][th][tw][3][2] = divd32[co][th][tw][1] ;
					
					 outputTiles[co][th][tw][3][3] = divd64[co][th][tw][0] ;
				} ;
			} ;
		} ;

		ClearMemSecret4(C, TH, TW, 2, divd2) ;
		ClearMemSecret4(C, TH, TW, 3, divd4) ;
		ClearMemSecret4(C, TH, TW, 4, divd8) ;
		ClearMemSecret4(C, TH, TW, 3, divd16) ;
		ClearMemSecret4(C, TH, TW, 2, divd32) ;
		ClearMemSecret4(C, TH, TW, 1, divd64) ;
	} ;

	*)

	for i2=[0:C] {
		for th=[0:TH] {
			for tw=[0:TW] {
				int32_pl i3 = th*m ;
				int32_pl i4 = tw*m ;

				for i=[0:m] {
					for j=[0:m] {
						int32_pl indH ;
						int32_pl indW ;

						indH = (th*m) + i ;
						indW = (tw*m) + j ;

						if ((indH < outH) && (indW < outW)) {
							outArr[0][indH][indW][i2] = outputTiles[i2][th][tw][i][j] ;
						} ;

					} ;
				} ;
			} ;
		} ;
	} ;

	ClearMemSecret5(C, TH, TW, m, m, outputTiles) ;
}

def void Conv2DWinoWrapper(int32_pl m, int32_pl r, int32_pl N, int32_pl H, int32_pl W, int32_pl CI, int32_pl CO, 
				   int32_pl zPadHLeft, int32_pl zPadHRight, int32_pl zPadWLeft, int32_pl zPadWRight, int32_pl G,
				   int64_al[N][H][W][CI] inputArr, 
				   int64_al[m+r-1][m+r-1][CI/G][CO] transformedFilter, 
				   int64_al[N][H+zPadHLeft+zPadHRight-r+1][W+zPadWLeft+zPadWRight-r+1][CO] outArr) {
	if (G == CI) {
		Conv2DWinoDW(m, r, N, H, W, CI, zPadHLeft, zPadHRight, zPadWLeft, zPadWRight, inputArr, transformedFilter, outArr) ;
	} else {
		Conv2DWinoSingleCOT(m, r, N, H, W, CI, CO, zPadHLeft, zPadHRight, zPadWLeft, zPadWRight, inputArr, transformedFilter, outArr) ;
	} ;
}


